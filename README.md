# React

<p align="center"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="165.93" height="162" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg></p>

#### [更多的 React 讨论](https://github.com/reactwg/react-18/discussions)

### 了解 React 18.x

- 🎢 声明式编写 UI【Vue、小程序、React、Flutter】响应式 `UI = render(state)`
- 🛟 组件化开发

- 🛵 使用 Node 进行服务端渲染(SSR)
- 🚁 使用 React Native 开发原生移动应用程序
- 🎑 2017 年 Facebook 推出的 ReactVR, 开发虚拟现实 Web 应用程序

**开发依赖 📝：**

- react：核心代码
- react-dom：渲染不同平台所需的核心代码
  - web 端：react-dom 将 jsx 最终渲染成真实的 DOM, 显示浏览器中
  - native 端：react-dom 将 jsx 最终渲染成原生的移动程序控件
- babel：jsx 转化 react 代码的工具(jsx 语法转化 React.creatElement)

```js
import React from "react";
import ReactDOM from "react-dom/client"; // 注意导出路径

// Before 18.x
ReactDOM.render(<div>React</div>, document.querSelector("#root"));

// After 18.x
const app = ReactDOM.creatRoot(document.querSelector("#root"));
app.render(<div>React</div>);
```

#### **类 class 和函数式组件 📖**

**class 组件：**

```js
// 通过 class 并且继承 React.Component 来创建组件
class App extends React.Component {
  // ...数据初始化,继承父类调用(可选：如果不需要初始化数据则不需要实现 constructor)
  constructor(props) {
    // 让父类的构造函数保存好 props, 以便在后面的方法中使用(State 也是如此)
    // 🚁 React 默认也会帮助处理保存 props, 不执行以下代码也是可以的
    super(props);

    // ...通常在这里初始化 state
    // ...通常在这里对组件的方法 this 提前绑定
    this.handelClick = this.handelClick.bind(this);
  }

  // ...组件方法
  handelClick() {
    // react 会对 this.setState() 传入的对象进行“合并”
    this.setState({ count: 1 });

    // ⚠️ 在当前函数被调用时, 函数内的 this 指向不一定是当前组件的实例对象(作为 jsx 方法回调(指针传递)默认是 undefined), 所以需要手动绑定 this, 或者🟢使用 react 的实验性语法 class fields handelClick = () => {} , 或者🟢z在 JSX 中事件回调中使用箭头函数
    // e.g. setTimeout(this.handelClick, 1000); // Wrong
    // e.g. const app = new App(); const handelClick = app.handelClick; handelClick(); this 指向就不是 App 的实例对象
    // e.g. <button onClick={() => this.handelClick()}>Click me</button>
    // ⚠️ setState 有可能是异步的,出于性能考虑,react 会将多个 setState() 的调用合并成一个,所以在这里不能依赖 this.state.count 的值来更新
    this.setState({ count: this.state.count + 1 }); // Wrong

    // 🟢 正确的做法是使在 setState 传入一个回调函数, 在 setState(callback) 中, callback 的第一个参数是上一次的 state, 第二个参数是上一次的 props
    this.setState((state, props) => {
      return { count: state.count + 1 };
    }); // Correct
  }

  // ...渲染内容的 render 方法(class 唯一必须要实现的方法) ,返回的 jsx 就是 react 的虚拟 DOM
  render() {
    return <div>{("any[]", "cannot be Object")}</div>;
  }
}
```

**函数式：**

```js
// 同样需要大写驼峰命名,不需要继承 React.Component
function App (){}

// 📝 没有 Hook 下
- 虽然会被更新挂载, 但是没有生命周期 🥽
- this 关键字不能指向组件实例(因为没有组件实例)
- 没有内部状态(State)
```

> Event
> event 对象与原生的传递方法相似 ,但是 React 的 event 对象是被 React 封装过的
>
> **React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault**
>
> **React 18.x 开始 setState 默认异步 🎢**

- event.preventDefault() 阻止默认行为(React 需要手动调用阻止默认行为)
- **bind 绑定 this 时需要注意 参数传递问题(bind 在多个参数存放位置)**
- 当需要传递多个参数时 ,建议在 jsx 中使用箭头函数

```js
// e.g.
<button onClick={this.handelClick.bind(this, '参数')}>Click me</button>

// 此时 event 参数会被传递到 handelClick 方法中的第二个参数中
handelClick(arg, event) {
  console.log(arg); // '参数'
}


// e.g.
handleClick = function (e) {
  console.log(this); // undefined
}

handleChange = handleClick.bind(this, '参数');
handleChange(event) // 需要在第二个参数中才能获取 event 对象
```

**列表渲染 🥽：**

元素的 key 只有放在就近的数组上下文中才有意义。
比方说, 如果提取出一个 ListItem 组件, 应该把 key 保留在数组中的这个 <ListItem /> 元素上, 而不是放在 ListItem 组件中的 <li> 元素上。

```js
function ListItem(props) {
  // 正确！这里不需要指定 key：
  return <li>{props.value}</li>;
  // return <li key={ props.value }>{props.value}</li>;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) => (
    // 正确！key 应该在数组的上下文中被指定
    <ListItem key={number.toString()} value={number} />
  ));
  return <ul>{listItems}</ul>;
}
```

> ⚠️ 组件名称必须是首字母大写的驼峰命名 , 例如：`<App />` , 否则 react 会认为是原生的 html 标签

如何存放组件的数据和方法呢？

- 通过 `this.state` 存放的数据通常是需要动态更新的数据
- 通过 `this.props` 存放的数据通常是父组件传递过来的数据(只读)
- 通过 `this.handelClick` 存放的方法通常是组件的事件处理方法(⚠️ this 指向问题)

`this.setState`做了什么？

- 更新组件的 state
- 自动调用 render 方法重新渲染组件

**JSX 语法 🎲：**
`JSX` 是 `JavaScript` 的语法扩展, 用来描述 `UI` 的长得像 `HTML` , 但是实际上是 `JavaScript` 语法的一种扩展

> 转换：`const element = <h1>🚣</h1>` => `React.createElement('h1', null, '🚣')`
> element 是一个对象, 有 type, props, key, ref 等属性,它不是一个字符串不是一个 DOM 元素,它是一个描述 DOM 元素的对象

all in js 🎷：

- html in js
- css in js
- js in js

#### **JSX 规范 🎨**

- JSX 元素(顶层)只能有一个根元素(使用 Fragment 可以包裹多个元素或者 Portals),**Portals 可以渲染子节点在不同 DOM 子树中**
- **阅读性 ,通常使用 () 包裹多行的 JSX ,并且可以实现 JSX 的换行**
- JSX 元素的属性名必须是驼峰命名法
- JSX 的自定义组件必须是大写字母开头的驼峰命名法
- JSX 标签可以是单*闭合标签* ,也可以是双闭合标签
- JSX 注释使用 { /\* \*/ } ,不能使用 { // } ,否则会被当做是一个表达式
- JSX 中变量的使用 ,使用 {} 包裹变量
- **JSX 中 class 属性使用 className(由于 jsx 与 js 耦合性,class 是关键字)**,使用 class React 可以识别 ,但是在浏览器中会报错(Warn: Invalid DOM property `class`. Did you mean `className`?) ,因为 class 是 js 中的关键字 ,在 jsx 中使用 class 会被当做是一个表达式(容易造成 babel 转换错误误解)
- JSX **不支持直接在 style 中使用字符串** ,需要使用对象的变量形式(🛟)

```js
// 动态 class

// 1
const className = `box ${isShow ? "show" : "hide"}`;

// 2
const classNameList = ["box"];
isShow && classNameList.push("show");

<div className={className}></div>;
<div className={classNameList}></div>; // 可以是一个数组

// 3 => 第三方库 classnames 📝
import classNames from "classnames";
<div className={classNames("box", { show: isShow })}></div>;
```

**JSX `<div>{变量}<div/>`中变量的说明 🎯：**

- `Number` | `String` | `Array(遍历)` 类型的变量直接渲染
- `Null` | `Undefined` ｜ `Boolean` 类型的变量不渲染(空 ,如果需要可以转换成字符串 ,toString()、String()、+''等)
- **`Object` 类型的变量会报错(需要转换成字符串 ,JSON.stringify()等), not valid as a React child**

**JSX 中 {} 说明 🎯：**
`{}` 中可以放置很多语法 , 例如：变量、表达式、函数、数组、三元表达式、逻辑运算符、条件运算符、函数调用等(**Object 会报错**)

**其它说明 🎯：**

#### React 哲学

为什么 React 要选择 JSX ？
🎤：因为它是一种更加优雅的方式来描述 UI , React 认为 UI(HTML) 代码和业务逻辑(JavaScript)代码是很难分离的(存在耦合关联性高,如某些状态改变时需要更新 UI), 所以 React 选择将 UI 代码和业务逻辑代码放在一起, 通过 JSX 语法来描述 UI , 通过 JavaScript 语法来描述业务逻辑.

#### JSX 的本质与原理

`<div></div>` 通过 babel 转化 `React.createElement('div', null, null)` React.createElement() 方法创建并返回指定类型的新的 React 元素(虚拟节点)对象 , 该元素将被 React 用来构建 DOM , 通常不直接使用 React.createElement() , 而是通过 JSX 来编写代码.

`createElement()`源码位于 `react/packages/react/src/ReactElement.js` 中

```js
export function createElement(type, config, children) {
  // ...

  // 新的 React 元素(虚拟节点)对象
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
```

> **ReactElement 调用返回的是一个对象 , 该对象包含了 React 元素(节点)的所有信息 , 例如：type、key、ref、self、source、owner、props** > **React 利用这些节点对象组成一个 Javascript 对象树(虚拟 DOM ) ,来构建 DOM , 以及更新 DOM**

[dome 测试](https://babeljs.io/repl)

![shadow](./image-20230205195946731.png)

> **其中 /\_#**PURE**\_/ 是 React 16.13 版本新增的语法 , 用于标记 JSX 转换后的代码 , 以便于 React DevTools 识别 ;并且用于告诉 是一个纯函数 ,可以进行 tree-shaking , 以便于减少打包体积**

#### 概念

React 组件相对其它组件更加灵活多样：

- 根据组件的定义方式分为：**函数式和类式**组件 ,18.x 后函数式组件使用较多(Hook,**Hook 弥补了函数式较多缺点**)
- 根据组件内部是否有状态分为：**无状态（Stateless Component）和有状态（Stateful Component）**组件
- 根不同职责分为：**展示型（Presentational Component 和容器型（Container Component**组件

> 一般情况下划分 `class` 是有状态的组件,`函数`是无状态组件
>
> 函数式维护自己的状态使用：`useState`(Hook)

### React 18.x 的核心语法

[关于 Eslint 报错的解决方案 `react/jsx-uses-react react/react-in-jsx-scope`](https://ja.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)

使用命令行添加 script 脚本

```sh
npm pkg set scripts.prepare="husky install"
```

**插件推荐 🪂 **

![image-20230206221725389](./image-20230206221725389.png)

`rcc`:快速生成 class 组件

`rpc`、`rce`...

#### 生命周期

![](./生命周期.png)

--- Mounting 挂载

1、类 constructor 构造函数初始化

2、执行 render 方法

3、组件被挂载到 DOM 执行 componentDidMount(官方建议:在此处发送网络请求、订阅事件)

--- Updating 更新(State 发生修改时)

4、重新执行 render 方法

5、组件被 React 更新挂载到 DOM 执行 componentDidUpdate(prevProps, prevState,snapshot)

--- Unmounting 卸载

6、组件即将被卸载执行 componentWillUnmount 方法(在此处取消订阅)

**不常用的生命周期：**

- getDerivedStateFromProps(nextProps, prevState)：在组件挂载和更新时调用，**返回一个对象来更新 state**，或者返回 null 来不更新任何内容
- getSnapshotBeforeUpdate(prevProps, prevState)：在最近一次渲染输出（提交到 DOM 节点）之前调用。**它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。**
- shouldComponentUpdate(nextProps, nextState)：**返回一个布尔值，用于指示组件是否应该更新。默认情况下，它返回 true。(控制是否执行 render 方法)**

[**更多详细生命周期**](https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle)

#### 组件通讯(嵌套)

// ...
通过 props、state、context、ref、redux、mobx、hook 等方式,实现组件间通讯

```js
class App extends React.Component {
  // ...不执行以下代码也 OK,React 默认会执行保存 Props
  constructor(props) {
    super(props);
  }
}
```

#### 受控输入空值

在[受控组件](https://zh-hans.reactjs.org/docs/forms.html#controlled-components)上指定 `value` 的 prop 会阻止用户更改输入。如果你指定了 `value`，但输入仍可编辑，则可能是你意外地将 `value` 设置为 `undefined` 或 `null`。

下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）

```js
ReactDOM.createRoot(mountNode).render(<input value="hi" />);

setTimeout(function () {
  ReactDOM.createRoot(mountNode).render(<input value={null} />);
}, 1000);
```

#### Props 类型 🎷

- 如果项目中默认使用 Flow 或 TypeScript，那么可以使用 Flow 或 TypeScript 来直接定义 Props 类型
- 如果项目中没有使用 Flow 或 TypeScript，那么可以使用 prop-types 库来定义 Props 类型,进行参数类型校验
  > 从 React v15.5 开始，React.PropTypes 已被弃(迁移到 prop-types)。请使用 prop-types 库代替。

##### Props 特别传递 🥽

```js
const info = {
  name: "aoe",
  age: 22,
};
<App {...info} />;
```

```js
import PropTypes from "prop-types";

class App extends React.Component {}


// 定义 Props 类型
App.propTypes = {
  city: PropTypes.string.isRequired,
  name: PropTypes.node, // 是否是节点
  age: PropTypes.instanceOf(Number), // 是否是 Number 类型
  sex:PropTypes.oneOf(['男','女']), // 是否是指定的值
  hobby:PropTypes.arrayOf(PropTypes.string), // 是否是数组
  info:PropTypes.shape({
    height:PropTypes.number,
    weight:PropTypes.func,
    element:PropTypes.element, // React 元素
  }), // 是否是对象
  address:PropTypes.exact({
    city:PropTypes.string,
    street:PropTypes.string,
  }), // 具有额外 key 警告的对象
  options:PropTypes.oneOfType([PropTypes.string,PropTypes.number]),// 是否是指定的任意类型
  value:PropTypes.string.isRequired, // 是否是必传参数
  function:PropTypes.any ,// 是否是任意类型
  // 自定义校验
  custom:function(props,propName,componentName){
    if(!/matchme/.test(props[propName])){
      return new Error(
        'Invalid prop `' + propName + '` supplied to' +
        ' `' + componentName + '`. Validation failed.'
      );
    }
  }
  // ...
};

// 默认 Props
App.defaultProps = {
  name: "张三",
}

// 从 ES 2022 开始，可以使用 static 关键字定义静态属性(默认值)
class App extends React.Component {
  static defaultProps = {
    // ...
  }
  // defaultProps 用于确保 this.props.name 在父组件中没有被指定时，有一个初始值。
  // PropTypes 类型检查发生在 defaultProps 赋值之后，所以类型检查也会应用于 defaultProps。
}
default export App;
```

[`更多类型校验说明`](https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html)

#### React 子传父组件的方法 

> React 同样也是通过 Props 来实现子组件向父组件传递数据的,与 Vue 不同的是 React 是通过父组件传递子组件一个回调函数给子组件,子组件通过调用这个回调函数来向父组件传递数据

#### React 插槽 

> React 没有插槽(Slot)的概念,但是组件 children 属性可以实现类似的功能或者可以通过 Props 来灵活实现插槽的功能

**children 属性 **

```js
// 父组件
<App>
  <div>子组件</div>
</App>;

// 子组件
class App extends React.Component {
  render() {
    // 多个子组件 children 是一个数组,单个子组件 children 是一个对象
    return <div>{this.props.children}</div>;
  }
}

App.propTypes = {
  children: PropTypes.node,
  // or
  children: PropTypes.array, // 多个子组件
};
```

> Children 弊端: 无法区分子组件的位置,无法灵活控制子组件的位置,无法控制子组件的数量,无法控制子组件的类型

**Props 属性**

```js
// 父组件
<App
  slots={{
    "i-mIronMan": <div>我是钢铁侠</div>,
    "i-mThor": <div>我是雷神</div>,
  }}
></App>;

// 子组件
class App extends React.Component {
  render() {
    // 多个子组件 children 是一个数组,单个子组件 children 是一个对象
    return <div>{this.props.slots["i-mIronMan"]}</div>;
  }
}
```

> **作用域插槽时,可以通过函数传参来实现**

#### Context 上下文 

> Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props
> Context 适用于一些数据被很多组件需要访问的情况。例如，当前认证的用户、主题或首选语言。(非父子组件传值)

```js
// 使用 Context
// 1. Provider
// 2. Consumer
// 3. useContext
// 创建 Context(需要创建,可以传入一个默认值,即使是在包裹层外面也可以共享默认值)
const AppContext = React.createContext(defaultValue);

// value is Object
// 使用 Provider 包裹 ,共享的组件必须是后代元素 ,value 为共享的数据
// Provider 可以嵌套使用,内层的 Provider 会覆盖外层的 Provider 值
// Provider 发生变化时,内部所有消费者都会重新渲染,会导致 Consumer 下所有的组件重新渲染
<AppContext.Provider value={value}>
  <App />
</AppContext.Provider>;
// 🪂🪂🪂 获取 value 的方式 App 组件中:
class App extends React.Component {
  // this.context 获取 value
}
// 声明 contextType 为 AppContext ,可以通过 this.context 获取 value(否则无法通过 this.context 获取 value,React 不知道你想要获取哪个 context)
// 可以在任何生命周期中访问到 this.context,包括 render 函数中
App.contextType = AppContext;

// 只能设置一个 contextType,可以结合 Consumer 使用多个 context
class App extends React.Component {
  static contextType = AppContext;
  render() {
    return (
      <BppContext.Consumer>
        // 其它的 value
        {(value) => {
          return <div>{value}</div>;
        }}
      </BppContext.Consumer>
    );
  }
}

// 使用 Consumer
// Consumer 函数使用,在 value 中获取共享的数据
function App() {
  return <AppContext.Consumer>{(value) => <div>{value}</div>}</AppContext.Consumer>;
}

// 使用 useContext
// useContext
// const value = useContext(AppContext);

// 使用 useContext 的 Hook
function App() {
  const value = useContext(AppContext);
  return <div>{value}</div>;
}
```

##### 事件总线 EventBus

> 事件总线适用于 React、Vue、Angular、小程序等框架
> 事件总线是一个全局的事件中心,可以在任何地方触发事件,也可以在任何地方监听事件

**库推荐：**

- mitt
- mitt-ee
- eventemitter3

```js
// mitt
// 1. 创建事件总线
const emitter = mitt();

// 2. 触发事件
emitter.emit("eventName", data);

// 3. 监听事件 - 📝 建议在 componentDidMount 中监听事件,在 componentWillUnmount 中移除事件
emitter.on("eventName", (data) => {
  console.log(data);
});

// 4. 移除事件
emitter.off("eventName", (data) => {
  console.log(data);
});

// 5. 移除所有事件
emitter.all.clear();
```

#### setState and createElement - 浅析 

> **🎲 setState 在数据发生变化时,会触发组件的 render 重新渲染,但是并不会立即触发 render,而是会将 setState 的数据放入队列中,等待合适的时机触发 render(异步的)** > **🛵 Vue 也同理,只不过开发者是看不到 render 的过程的,因为 Vue 会将模板编译成 render 函数,在数据发生变化时,会触发 render 函数重新渲染** > **🚁 React 没有像 Vue 一样对数据进行劫持并在 setter 中触发 render,而是通过 setState 来触发 render,所以 React 需要手动调用 setState 来触发 render 进行更新**

---

**`???`** 如果在 setState 中更新的值和之前的值一样,会发生什么?
**React 还是会触发 render,但是不会更新 DOM,因为 React 会对比新旧数据,如果新旧数据一样,就不会更新 DOM**,同样可以使用 shouldComponentUpdate 来优化

---

> #### PureComponent、memo
>
> **🛴 由于每次都需要通过 shouldComponentUpdate 来判断是否需要更新,所以 React 16.3 版本之后提供了 PureComponent 来解决这个问题,它会自动判断是否需要更新,如果不需要更新,就不会触发 render > 但是 PureComponent 只能对 props 和 state 进行浅比较,如果 props 和 state 中有复杂数据类型,就会出现问题, memo 用于函数组件的判断**

> ---

🤨 在 class 组件中并没有看到 setState 的实现,但是在组件中却可以使用,这是为什么?
1、拉取 React 源码

```sh
git clone https://github.com/facebook/react.git
```

2、在 `packages/react/index.js` 中可以找到所有的导出
![image-20230206221725389](/Volumes/aoe/web-design/pers-code/web-react-simple/截屏 2023-02-08 20.23.12.png)

3、查看 React 源码,搜索 `Component.prototype.setState`

```js
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  // 判断 partialState 是否是对象或者函数,如果不是,就抛出异常
  if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
    throw new Error("setState(...): takes an object of state variables to update or a " + "function which returns an object of state variables.");
  }

  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
```

4、查看 createElment 源码,`packages/react/src/ReactElement.js`

> 发现实际 `createElement('div',{},子元素,子元素,子元素)` 中传入的参数方式不是按照 React createElement 中第三个参数 children 方式传入的,而是按照 `arguments`(剩余参数) 的方式传入的,所以在 `ReactElement.js` 中可以看到 `createElement` 的实现和对 `arguments` 的处理

```js
// 获取剩余参数的长度
const childrenLength = arguments.length - 2;

// 等于 1 说明只有一个子元素,这就是上面提到的一个元素就直接返回
if (childrenLength === 1) {
  props.children = children;

  // 大于 1 说明有多个子元素,这就是上面提到的多个元素就放到数组中
} else if (childrenLength > 1) {
  const childArray = Array(childrenLength);
  for (let i = 0; i < childrenLength; i++) {
    childArray[i] = arguments[i + 2];
  }

  // 这里是开发环境下,如果是开发环境,就冻结数组,防止数组被修改(性能考虑)
  if (__DEV__) {
    if (Object.freeze) {
      Object.freeze(childArray);
    }
  }
  props.children = childArray;
}
```

<img src="./%E6%88%AA%E5%B1%8F2023-02-08%2020.33.00.png" style="zoom:150%;" />

##### setState 异步详细解析

setState 回调函数

> setState 可以在回调函数中编写**新的 State 逻辑**
> 将 state 和 props 作为参数传入回调函数中，可以获取到更新前的 state 和 props。

```js
setState({}, (state, props) => {
  console.log(state, props);
});
```

---

setState 的调用不会立即将传入的对象合并触发组件的更新重新渲染组件。这个过程是异步的(**18.x 后默认异步**)，也就是说多次调用 setState 会被合并成一次更新(加入队列)。这样做的好处是：

- 可以提高性能，避免不必要的频繁渲染,引起回流重绘
- **如果同步更新 state(居于多个 setState 批量更新问题展开),但是还没 执行 render 更新试图,那么 state 和 props 就不是最新的(不能同步),这样就会导致一些问题(保证 state 没有被更新的时候, 子组件 prop... 保持一致)**

**由于是异步的无法的知何时更新完成,何时书写完成后的逻辑代码,所以 setState 提供了一个回调函数(第二个参数),在更新完成后执行**

[更多详细介绍](https://github.com/reactwg/react-18/discussions/21)

```js
// 对象合并完成后,执行回调函数
this.setState({}, () => {
  console.log(this.state.count);
});

// 使用函数方式准确获取最新的 state
this.setState((state, props) => {
  // 思考这里的行参 state 是上一次更新后的 state,那么在这里(函数方式)使用 this.state 是不是就是上一次更新后的 state【🎢 很遗憾不是,依然是首次更新前的 state】

  return {
    count: state.count + 1,
  };
});
```

##### flushSync 18.x 后同步执行 setState

18.x 前的版本,setState 是同步的

```js
import { flushSync } from "react-dom";

flushSync(() => {
  this.setState({ count: 1 });
});
console.log(this.state.count); // 1
```

#### SCU 性能优化

React 更新机制:

`JSX` -> `React.createElement` -> `虚拟节点` -> `虚拟DOM` -> `真实DOM`

更新流程:

`props or state 改变` -> `render重新执行` -> `产生新的虚拟DOM树` -> `新旧虚拟DOM树进行 diff` -> `计算差异进行更新` -> `更新到真实DOM`

如果每次 DOM 对比使用交叉对比方式, 将产生较大的对比次数(O(n 的 3 次方))非常大的性能开销[n 为树的节点数]

于是 React 对此对比方法进行优化, 优化为 O(n):

- 同级节点才进行比较, 不会跨级进行比较(父不会到子层比较)
- 不同类型的节点产生不同的树结构(父节点不同整棵树重新生成,一般顶层节点较少改变,底层节点变化较多,所以重新渲染不同类型的不会产生较大的性能开销)
- 开发时,使用 key 来指定哪些节点在不同的渲染下保持稳定(同层比较时发现类型不同,可以通过查找 key 节点尽量复用不需要重新更新)

> ##### 不同类型的节点产生不同的树结构:
>
> 当父组件数据变化时,嵌套的所有子组件都会调用 render 重新生成(产生虚拟开销,如果子组件类型不变数据不变不会重新更新到真实 DOM 上)
>
> 解决办法：
>
> **一：使用 shouldComponentUpdate(SCU) 阻止调用 render**
>
> ```js
> // 最新的props、state(被修改之后的)
> shouldComponentUpdate(nextProps,nextState){
>   // this.state 是旧的,需要通过参数获取最新的
>
>   // ...对新旧数据进行判断是否需要更新
>   this.state.xxx === nextState.xxx
> }
> ```
>
> **二：React 内置了拥有第一种方法的父构造函数类组件【PureComponent、memo】**
>
> **🛴 由于每次都需要通过 shouldComponentUpdate 来判断是否需要更新,所以 React 16.3 版本之后提供了 PureComponent 来解决这个问题,它会自动判断是否需要更新,如果不需要更新,就不会触发 render, 但是 PureComponent 只能对 props 和 state 进行浅比较,如果 props 和 state 中有复杂数据类型,就会出现问题**
>
> **三：函数组件的性能优化 memo**
>
> ```js
> // 通过 memo 包裹函数组件
> import { memo } from "react";
> export const App = memo(function App() {});
> ```

#### 不可变的力量

> 不要试图直接改变 state 的数据(push、unshift...), 如果需要改变请直接修改覆盖变量的指针(修改对象的引用值)
>
> ```js
> this.state = {
> a: { xxx: "" },
> b: [1, 2, 3, 4, 5],
> };
> 
> // 重新浅层拷贝一份并且重新指向地址值, 只对浅层数据进行笔记
> const a = { ...this.state.a }; // !=this.state.a
> a["yyy"] = "";
> this.setState({ a });
> // 原理
> shouldComponentUpdate(nextProps,nextState){
>   shallowEqual(nextProps,this.props) // 浅的比较
>   shallowEqual(nextState,this.state)
> }
> 
> // 在 PureComponent 中无法引起组件重新渲染
> this.state.b.push(6)
> this.setState({b:this.state.b})
> 
> // 主要地址值判断
> ```
>
> ###### PureComponent 🍇
>
> ```js
> /**
>  * 为SCU提供默认浅相等检查的便利组件。
>  */
> function PureComponent(props, context, updater) {
>   this.props = props;
>   this.context = context;
>   // 如果一个组件有字符串引用，我们稍后将分配一个不同的对象。
>   this.refs = emptyObject;
>   this.updater = updater || ReactNoopUpdateQueue;
> }
> 
> 
> const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
> pureComponentPrototype.constructor = PureComponent;
> // 避免为这些方法进行额外的原型跳转。
> assign(pureComponentPrototype, Component.prototype);
> pureComponentPrototype.isPureReactComponent = true; // 给原型添加 isPureReactComponent 属性, 用于渲染判断是否需要比较更新
> 
> // 检查组件是否更新, 返回布尔值
> function checkShouldComponentUpdate(
>   workInProgress: Fiber,
>   ctor: any,
>   oldProps: any,
>   newProps: any,
>   oldState: any,
>   newState: any,
>   nextContext: any,
> ) {
>   const instance = workInProgress.stateNode;
>   if (typeof instance.shouldComponentUpdate === 'function') {
>     // 获取组件中的 shouldComponentUpdate 方法进行调用(由开发者提供的)  ---  shouldComponentUpdate(newProps,newState,nextContext)
>     let shouldUpdate = instance.shouldComponentUpdate(
>       newProps,
>       newState,
>       nextContext,
>     );
>     if (__DEV__) {
>       if (
>         debugRenderPhaseSideEffectsForStrictMode &&
>         workInProgress.mode & StrictLegacyMode
>       ) {
>         setIsStrictModeForDevtools(true);
>         try {
>           // 额外调用该函数以帮助检测副作用。
>           shouldUpdate = instance.shouldComponentUpdate(
>             newProps,
>             newState,
>             nextContext,
>           );
>         } finally {
>           setIsStrictModeForDevtools(false);
>         }
>       }
>       if (shouldUpdate === undefined) {
>         console.error(
>           '%s.shouldComponentUpdate(): Returned undefined instead of a ' +
>             'boolean value. Make sure to return true or false.',
>           getComponentNameFromType(ctor) || 'Component',
>         );
>       }
>     }
> 
>     return shouldUpdate;
>   }
>     
> 
>   // 如果是一个纯函数情况下, 通过原型 isPureReactComponent 调用 shallowEqual 进行浅层比较
>   if (ctor.prototype && ctor.prototype.isPureReactComponent) {
>     return (
>       !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
>     );
>   }
> 
>   return true;
> }
> ```
>
> ###### shallowEqual 🥦
>
> ```js
> /**
>  * 通过遍历对象上的键并返回false来执行相等性
>  * 当任意键的参数值不严格相等时。
>  * 当所有键的值严格相等时返回true。
>  */
> function shallowEqual(objA: mixed, objB: mixed): boolean {
>   // 对象浅层比较 state 的地址值相同返回 true 不更新
>   if (is(objA, objB)) {
>     return true;
>   }
> 
>   if (
>     typeof objA !== 'object' ||
>     objA === null ||
>     typeof objB !== 'object' ||
>     objB === null
>   ) {
>     return false;
>   }
> 
>   const keysA = Object.keys(objA);
>   const keysB = Object.keys(objB);
> 
>   // key length ！== 返回 false 更新
>   if (keysA.length !== keysB.length) {
>     return false;
>   }
> 
>   // Test for A's keys different from B.
>   // 循环比较 state 的 key 是否相等 
>   for (let i = 0; i < keysA.length; i++) {
>     const currentKey = keysA[i];
>     if (
>       !hasOwnProperty.call(objB, currentKey) ||
>       !is(objA[currentKey], objB[currentKey])
>     ) {
>       return false;
>     }
>   }
> 
>   // 没有再深层的比较了
>   return true;
> }
> 
> ```



#### Ref 获取 DOM



```js
// 方式一  ---  不推荐,已废弃
<div ref='e'><div/>
this.ref.e
  
// 方式二 --- 提前创建 ref
import {createRef} from 'react'
this.e = createRef()
<div ref={this.e}><div/>
  
// 方式二 --- 回调方式
this.e = null
<div ref={ el => this.e = el }><div/>
  
// --- 父子嵌套同样适用 class 组件🍟, 可通过 ref 调用子组件方法 --- //

```

> **由于 函数式 组件没有组件实例, 无法通过以上方法获取组件实例**
>
> ```js
> // 解决
> 
> // 通过传参方式传到子组件绑定, 非常不推荐
> 
> // 通过高阶函数 forwardRef 传入组件函数作为回调, 并且在第二个参数中接受 ref 对组件内元素进行绑定
> import { forwardRef } from 'react'
> const Bpp = forwardRef(function(prop,ref){
> return (<div ref={ref}><div/>)
> })
> 
> <Bpp ref = {xxx}/>
> ```



#### 

#### 受控组件、非受控组件

> 如果指定了 `value`, 但输入仍可编辑，则可能是意外地将 `value` 设置为 `undefined` 或 `null`（输入最初被锁定，但在短时间延迟后变为可编辑）

**如果需要将不可编辑的转化为一个可编辑的, 则需要为元素添加一个 onChang 事件, 进行双向绑定**

**`在一个受控组件中，表单数据是由 React 组件来管理的。另一种是非受控组件，这时表单数据将交由 DOM 节点来处理。`**

```js
<input value={xxx} onChange={e => this.inputChange(e)} />
  
inputChange(e){
  e.targer.value
}


// 	受控组件
<input value={xxx} />
<input value={xxx} onChange={e => this.inputChange(e)}>
  
// 	非受控组件
<input type='text' />
//  非受控组件默认值 or 获取 value, defaultValue 可以继续输入编辑
<input type='text' defaultValue={value} ref={input} />
  
// 🥁 Array.from
const data = Array.from( 伪数组, (item)=>item )
```



#### 高阶组件 

**高阶函数：需要满足如下条件之一**

- 接受一个或多个函数作为输入, 如map、filter、reduce...
- 输出一个函数, 如柯里化函数

**高阶组件简(HOC), 参数为组件, 返回值为一个新组件(本质上不是一个组件而是一个函数), 如 memo、forwardRef**

```js
function newComponent(cpn){
  class NewCpn extends PureComponent{
    // ... cpn 处理
  }
  // 🥎 class 类名可以通过 displayName 来修改
  NewCpn.displayName = "newComponent"
  return NewCpn
}

const newComponent = newComponent(<div></div>)
                                  
// 高阶组件不属于 React API 的一部份, 它是基于 React 的组合特性而形成的设计模式
// 它在一些 React 第三方库中非常常见
- redux 的 connect
- react-router 的 withRouter
```



**使用场景一：注入数据、数据共享**

```js
function extInfo(cpn){
  class NewCpn extends PureComponent{
    constructor(){
      super()
      
      this.state={
        info:{
          a:'xxx',
          b:'yyy',
          c:'zzz'
        }
      }
    }
    render(){
      // 给传入的组件注入信息
      return <cpn {...this.state.info} />
    }
  }
  return NewCpn
}

function App(props){
  return ...
}
function Bpp(props){
  return ...
}
  
const ExtApp = extInfo(App)
const ExtBpp = extInfo(Bpp)
const ExtCpp = extInfo(function(props){
  return <div>{props.a}</div>
})

// BUG 当注入后再往组件上添加属性如何操作???
<ExtCpp value={value} />
  
// 解决🥏
function extInfo(cpn){
  class NewCpn extends PureComponent{
    // ...
    render(){
      // 再添加一个 props 属性得以解决
      return <cpn { this.props } {...this.state.info} />
    }
  }
  return NewCpn
}
 
  
  
**案例**
import { createContext } from 'react'
const ThemeContext = createContext({color:'red',size:30})

// ... 省略定义 context value

class App extends React.Component {
  // this.context 获取 value
  
  // 使用多个 context 方法
  render(){
    return (
      <ThemeContext.Consumer>
      {
        value => <div>{value.color}</div>
      }
      </ThemeContext.Consumer>
    )
  }
}
App.ContextType = ThemeContext // 这种定义方法只能在一个组件中使用一个 context

// 🍶以上做法太过机械重复操作太多, 可以使用 高阶组件 进行优化
function App（cpn）{
  return props =>{
    return (
      <ThemeContext.Consumer>
      {
        value => <cpn {...value} {...props}>{value.color}</cpn>
      }
      </ThemeContext.Consumer>
    )
  }
}
```



**使用场景二：**

```js
// 使用高阶组件对组件进行鉴权, 统一在高阶组件内部进行鉴权
function AuthOfCpn(cnp){
  // 获取 token 等权限标识
  const isToken = ...
  return props=>(<div>{isToken?<cnp {...props} /> : '请先登陆'}</div>)
}
```



> ##### forceUpdate(不推荐)
>
>  🍰 **可使用`this.forceUpdate()`强制刷新页面**



**使用场景三：生命周期劫持**

```js
// 获取组件渲染所需的时间
class App extends React.PureComponent {
  // 组件即将被挂载之前执行(通常不建议使用)
  componentWillMount(){
    // 记录时间戳
  }
  // 同=于, UNSAFE_componentWillMount(16.3被弃用)
  
  componentDidMount(){
    // 计算时间差
  }
  render(){
    return (
      
    )
  }
}
```

> 早起 React 也有提供 Mixin 进行复用的, 但是目前已经不建议使用, 可能会相互依赖相互耦合不利于代码维护、相互冲突方法属性, 处理麻烦



> 由于 Mixin 的缺点, 可以使用 **高阶组件 or Hook** 代替, 当然高阶组件也有些缺点
>
> - 需要在原组件(参数组件)基础上进行包裹嵌套返回, 如果大量使用高阶组件, 就会产生非常多的嵌套关系, 这让调试变得非常困难
> - 高阶组件可以劫持 Props, 在不遵守约定情况下, 可能会造成冲突

> **Hook 的出现解决以上诸多问题, 是开创性的, 如 this 指向、高阶组件嵌套问题**



#### Portals

> **将内容渲染独立于父组件, 甚至是独立于当前挂载到真实的 DOM(默认挂载在 id = ‘root’ 的 DOM 上), 可以渲染子节点在不同 DOM 树中(如 root 之外的 DOM)**

```js
// 在 Vue3 中使用 teleport 实现

// Reac...
<div id='root'></div>
<div id='system'></div>


import React from "react";
import ReactDOM from "react-dom/client"; // 注意导出路径Portals
import {Portals} from "react-dom;


// After 18.x
const app = ReactDOM.creatRoot(document.querSelector("#root"));
app.render(<App />);
class App extends React.PureComponent {
  
  render(){
    return (<div>
            <h1>ROOT</h1>		
            {createPortals(
                <h2>ROOT</h2>,
                document.querSelector("#system")
            )}
						</div>)
  }
}
```



#### Fragment 片段

> 用于代替最外层包裹的 div(此 div 是多余不需要的, 只不过在返回时如果是多层兄弟 节点时需要进行包裹), Fragment不会渲染到真实的 DOM 中, 相当于 Vue Template
>
> ```js
> render(){
>     return (<Fragment>
>             <h1>ROOT</h1>		
>             {createPortals(
>                 <h2>ROOT</h2>,
>                 document.querSelector("#system")
>             )}
> 						</Fragment>
> 		)
> }
>   
> // Vue3 中在 template 书写代码时不需要一个根节点同样也是使用 Fragment, 当发现组件中没有根包裹时, Vue 使用 Fragment 对组件进行包裹
> ```

> **Fragment 语法糖🍬：直接使用空的标签进行包裹也是一样的 `<>...</>`**
>
> **注意⚠️：(Vue3 在 transition 组件中使用会出现问题), 不是所有地方都能使用 Fragment 的语法糖, 如需要在 <></> 上绑定属性 key...**



#### 严格模式 StrictMode

> **StrictMode 是一个组件**用来突出显示应用程序潜在的问题的根据, 与 Fargment 一样, 它不会渲染任何 可见的 UI, **它为其后代元素触发额外的检查和警告**, **仅在开发模式下运行**
>
> ```js
> ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
>   <React.StrictMode>
>     <App />
>   </React.StrictMode>
> );
> 
> // 当开启之后如在代码中使用 UNSAFE_componentWillMount(16.3被弃用)、findDomNode, 会在控制台中报警告
> ```
>
> **在 StrictMode 下, render() 将执行两次,并且在两次渲染之间,所有的生命周期都会被调用两次。这使得在开发模式下更容易发现潜在的问题。但是,请注意,这些生命周期方法仍然只会被调用一次。**
>
> 在 18.x 后, 安装 dev 开发根据后, StrictMode 下第二次显示的输出呈现灰色
>
> - 识别不安全的生命周期
> - 有关使用过时字符串ref API的警告(findDOMNode)
> - 有关使用过时findDOMNode API的警告
> - 检测意外的副作用
> - 检测过时的context API



#### 过渡动画

使用如 `react-transition-group` 库[体积小]完成过渡动画(前身是 React 为开发者提供的动画插件:`react-addons-css-transition-group`, 方便实现组件的 入场 和 出场 动画

其它:`react-Motion`、`react Spring`

```js
// react-transition-group 主要包含四个组件：
- Transition：与平台无关、不一定要结合 Css
- CssTransition：通常前端开发使用此组件, 基于 Transition 构建的
- SwitchTransition：两个组件显示隐藏切换时使用此组件, 相当于 Vue 的 modes 属性
- TransitionGroup：将多个组件包裹其中,一般应用于列表中
```



###### CssTransition

- in 控制显示隐藏
- className 动画类名
- timeout 动画执行时间, 必填 - 决定何时删除添加过渡类名, 过渡时间由 css 控制, 可以是一个对象 { appear:xxx,enter:xxx,... }
- unmountOnExit 组件隐藏时是否对组件进行卸载, 必填
- key 配合 SwitchTransition 使用时必填

钩子函数：

- onEnter 加入之前
- onEntering 正在执行加入动画
- onEntered 执行加入结束
- onExit 开始离开之前
- onExiting ...
- onExited ...

状态：appear、enter、exit

三种状态:

1、开始状态：对应类 -appear、-enter、exit

2、执行动画：对应类 -appear-active、-enter-active、-exit-active

3、执行结束：对应类 -appear-done、-enter-done、-exit-active

```css
// 加入时的动画 in = true
.class-enter{
  opacity:0
}

.class-enter-active{
  opacity:1;
  transition:opacity 1s;
}
// 以上两步是核心

.class-enter-done{
  // ...
}

// 推出时的动画 in = false
.class-active{
  opacity:1
}

.class-enter-active{
  opacity:0;
  transition:opacity 1s;
}
// 以上两步是核心

.class-active-done{
  // ...
}
```



**解决不关闭 StrictMode 下 CssTransition 报 findDOMNode 错误(其它组件同理)**

```js
this.refValue = createRef()

<CssTransition
// ...
nodeRef={ this.refValue } // 赋值到组件的 nodeRef
>
  <div ref={ this.refValue }></div> // 绑定 ref
</CssTransition>
```



###### SwitchTransition

与 Vue 的 mode 属性相似, 控制两个组件之间的切换, 先出后进(out-in) or 先进后出(in-out), 需要包裹 CSSTransition 使用

```js
 render() {
    const { logo } = this;
    const { isGo } = this.state;
    const { slot } = this.props;
    console.log(slot);

    return (
      <>
        <button onClick={this.handleState}>{isGo ? "NO" : "OFF"}</button>
        <SwitchTransition mode="out-in">
          // 基于 CSSTransition, CSSTransition key 必填一个唯一的
          // 不需要设置 in
          <CSSTransition nodeRef={logo} key={isGo ? "ok" : "fail"} classNames="with" timeout={2000}>
            <div ref={logo}>
              <div>{isGo ? slot.react() : slot.vite()}</div>
              <h1>{isGo ? "React" : "Vite"}</h1>
            </div>
          </CSSTransition>
        </SwitchTransition>
      </>
    );
  }
```

```js
// memo 高阶组件第二参数是个函数, 同样可以自定义判断是否需要更新
function memo<Props>(
  type: React$ElementType,
  compare?: (oldProps: Props, newProps: Props) => boolean,
) 

// 关于组件更新的, 正确应该在函数外部定义🍓
const slot = {
  vite: "/vite.svg",
  react: reactLogo,
};
function App() {
  const [count, setCount] = useState(0);
	// 这里同理, 函数重新执行, slot 重新修改地址值
  return (
    <div className="App">
      <Home slot={/* 这里不能直接书写一个对象, 否则当 App 更新, slot 重新被赋值, 地址值同样改变, 子组件同样更新 */}></Home>

    </div>
  );
}
```



###### TransitionGroup

TransitionGroup 默认最终渲染出来的是一个 div 标签, 它的子组件可以是 `CSSTransition` 或 `Transition` 等过渡组件

属性：

- component 定义 TransitionGroup 渲染成什么元素

```js
render() {
  return (
      <>
        <button onClick={this.handleAdd}>新增</button>
        <button onClick={this.handleDelete}>删除</button>
        <TransitionGroup>
          {this.state.list.map(({ name = "", id = "" }, index: number) => {
            return (
              <CSSTransition timeout={2000} classNames="group" key={id}>
                // 在 li 里定义 transitionDelay 其值为当前元素的索引乘以 100 毫秒，表示前一个元素完成动画后，等待一定时间后再开始动画
                <li style={{ transitionDelay: `${100 * index}ms` }}>
                  {name} - {id}
                </li>
              </CSSTransition>
            );
          })}
        </TransitionGroup>
      </>
    );
  }
```

#### 如何编写 CSS

CSS 的设计不是为组件化而生的, 在组件化中选择合适的 CSS 解决方案应该符合以下条件：



- 拥有局部作用域的 css, 不会污染其它组件的样式
- 可以编写动态的 css, 可以获得当前组件的一些状态, 根据状态生成不同的样式
- 支持原声 css 所有特性, 动画、伪类、媒体查询...
- 编写方便

###### 内联样式

**JSX 不支持直接在内联 style 中使用字符串 ,需要使用对象的变量形式(🛟)**

- 对象属性需要以驼峰命名, 不支持原生 -(font-size) 写法
- 无法编写某些样式写法(伪类、伪元素), js 中没有 css 样式提示
- 代码混乱, 在 js 中编写样式

###### CSS Module

CSS Module 并不是 React 特有的解决方案, 而是所有使用了类似 webpack 的打包构建工具的配置环境下都可以使用, 如果在其它项目构建工具中使用它, 则需要进行配置, 如：webpack.config.js `modules:true`

**React 脚手架和 Vite 默认内置该配置：**

**.css、.scss、.less 等样式文件都需要修改成 .module.css、.module.scss、...,  之后引用进行使用**

任何以 `.module.css` 为后缀名的 CSS 文件都被认为是一个 CSS Module。导入这样的文件会返回一个相应的模块对象

```css
/* example.module.css */
.red {
  color: red;
}


// App.tsx
import classes from './example.module.css'
<div className={classes.red}></div>

// 最终生成 文件名称_类名_哈希值 - 保证唯一性
<div class="App_red_42Iui"></div>
```

**🍇 CSS Module 适用于编写普通的 css 样式**

CSS Module 缺点：

- js 中引用的类名不能使用连接符(-,.red-color) js 不识别
- 所有 className 都必须使用 `{style.className}的形式编写`
- 不方便动态修改样式, 依然使用内联样式动态修改

> Vite 🥥
>
> 如果 `css.modules.localsConvention` 设置开启了 camelCase 格式变量名转换（例如 `localsConvention: 'camelCaseOnly'`），可以使用按名导入
>
> ```js
> // .apply-color -> applyColor(驼峰转化)
> import { applyColor } from './example.module.css'
> document.getElementById('foo').className = applyColor
> ```



###### CSS in JS

**‘CSS in JS’是指一种模式, CSS 由 JS 生成, 而不是在外部文件定义(不是 React 的一部份, 而是由第三方库提供)**

> React 认为 UI(HTML) 代码和业务逻辑(JavaScript)代码是很难分离的, 所以 React 选择将 UI 代码和业务逻辑代码放在一起, 通过 JSX 语法来描述 UI , 通过 JavaScript 语法来描述业务逻辑, 样式也是 UI 的一部份, 所以也写进 jsx 中(All in JS)

**使用`styled-components`库进行 css in js 开发**

**css in js 通过 js 赋予 css 更多的能力, 如：类似预处理器一样的样式嵌套、函数定义、逻辑服用、动态修改状态等, 通过 js 代码来赋予, 虽然 css 预处理器同样具备以上个别能力, 但是获取动态状态依然不是很好处理**(目前来说该方案是最受欢迎)

> **styled.div`` 是调用函数的另外一种写法 == styled.div()**
>
> css in js 同样适用 css 预处理器的写法

```js
import styled from "styled-components";

// styled.div 是一个返回React div 组件的函数(标签模板字符串)
const HomeWrapper = styled.div`
  width: 100%;
  // 给子定义样式
  .p-box{
  	color:red;
  	&：hover{
  		font-size:22px;
  	}
  }
`;

<div>
  CSS in JS
	<p className="p-box"></p> // 子样式同样可以使用
</div>
// 替换为:          --- 将 div 标签替换为 styled.div`` 返回的组件 
<HomeWrapper>CSS in JS</HomeWrapper>

// fun`react is ${name} in all, .e.g. ${value} is a framework`
// 输出:[
//     [ 'react is ', ' in all, .e.g. ', ' is a framework' ],
//     name,
//     value
//     ]
// 以插入的变量位置对字符串进行分割

```

###### 接收传入的 props

css in js 可以接受由外部传入的 props, 如:

**`<HomeWrapper color={color} size={size}>CSS in JS</HomeWrapper>`**

**- 通过 attrs 给模板属性提供默认值**

**- 通过定义 variables.ts 定义统一的变量风格(推荐)**

**- 支持样式继承**

**使用 styled-components - ThemeProvider 在最顶层定义变量进行传递继承**

```js
const HomeWrapper = styled.div`
  // 使用模板字符串传入一个回调函数并接收一个 porps 形参
  width: `${porps=>props.size}px`;
  
`;

// attrs 定义传入 js 变量的默认值
const HomeWrappe = styled.div.attrs(props=>({
  size:props.size || 50
}))`
  width: `${porps=>props.size}px`;
`
  
  
// variables.ts
export const appBg = '#ffc673'

// styled 文件
import { appBg } from 'variables.ts'
const HomeWrappe = styled.div`
  color:`appBg`
`
  
  
// styled-components
import { ThemeProvider } from 'styled-components'

<ThemeProvider theme={{color:red}}>
	<App>
  	<Bpp />
  </App>
</ThemeProvider>

// Bpp.tsx styled
const BppStyled = styled.div`
	bpp{
		color:`${props=>props.theme.color}`
	}
`
    
    
// 继承 HomeWrapper 样式 - 继承 div 组件属性样式 
const Cpp = styled(HomeWrapper)`
color:xxx
// 继承 width
`
```



###### classnames 库

`pnpm add classnames`

与 vue 模板语法相似:

- `classNames('foo',{bar:true})` // foo bar

- `classNames('foo',{bar:false})` // foo

- `classNames({foo:true},{bar:true})` // foo bar

- `classNames({foo:true,bar:true}) ` // foo bar

- `classNames(['aaa',{foo:true,bar:true}])`

- `classNames(null,false,undefind,0,1,{bar:null})` // 1

- ... ...

  ```js
  import _c from 'classnames'
  className={_c(xxx,{yyy:false})}
  ```

  

### Rudex 状态管理器使用 🥽

纯函数：

- 确定的输入一定产生确定的输出(函数相同的输入需要产生相同的输出)
- 函数在执行过程中不能产生副作用

### React Router 6.x 路由

### React Hook 的使用 🪂

### React 实战 🛴

### React 项目自动化部署

```

```
